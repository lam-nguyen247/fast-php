<?php

namespace Fast\FileSystem;

use ErrorException;

class FileSystem {
	/**
	 * Determine if a file or directory exists.
	 *
	 * @param string $path
	 * @return bool
	 */
	public function exists(string $path): bool {
		return file_exists($path);
	}

	/**
	 * Get the contents of a file.
	 *
	 * @param string $path
	 * @param bool $lock
	 * @return string
	 *
	 * @throws FileSystemException
	 */
	public function get(string $path, $lock = false): string {
		if ($this->isFile($path)) {
			return $lock ? $this->sharedGet($path) : file_get_contents($path);
		}

		throw new FileSystemException("File does not exist at path {$path}");
	}

	/**
	 * Get contents of a file with shared access.
	 *
	 * @param string $path
	 * @return string
	 */
	public function sharedGet(string $path): string {
		$contents = '';

		$handle = fopen($path, 'rb');

		if ($handle) {
			try {
				if (flock($handle, LOCK_SH)) {
					clearstatcache(true, $path);

					$contents = fread($handle, $this->size($path) ?: 1);

					flock($handle, LOCK_UN);
				}
			} finally {
				fclose($handle);
			}
		}

		return $contents;
	}

	/**
	 * Write the contents of a file.
	 *
	 * @param string $path
	 * @param string $contents
	 * @param bool $lock
	 * @return int
	 */
	public function put(string $path, string $contents, bool $lock = false): int {
		return file_put_contents($path, $contents, $lock ? LOCK_EX : 0);
	}

	/**
	 * Append to a file.
	 *
	 * @param string $path
	 * @param string $data
	 * @return int
	 */
	public function append(string $path, string $data): int {
		return file_put_contents($path, $data, FILE_APPEND);
	}

	/**
	 * Get or set UNIX mode of a file or directory.
	 *
	 * @param string $path
	 * @param int|null $mode
	 * @return mixed
	 */
	public function chmod(string $path, ?int $mode = null): mixed {
		if (!is_null($mode)) {
			return chmod($path, $mode);
		}

		return substr(sprintf('%o', fileperms($path)), -4);
	}

	/**
	 * Delete the file at a given path.
	 *
	 * @param array|string $paths
	 * @return bool
	 */
	public function delete(array|string $paths): bool {
		$paths = is_array($paths) ? $paths : func_get_args();

		$success = true;

		foreach ($paths as $path) {
			try {
				if (!@unlink($path)) {
					$success = false;
				}
			} catch (ErrorException $e) {
				$success = false;
			}
		}

		return $success;
	}

	/**
	 * Move a file to a new location.
	 *
	 * @param string $path
	 * @param string $target
	 * @return bool
	 */
	public function move(string $path, string $target): bool {
		return rename($path, $target);
	}

	/**
	 * Copy a file to a new location.
	 *
	 * @param string $path
	 * @param string $target
	 * @return bool
	 */
	public function copy(string $path, string $target): bool {
		return copy($path, $target);
	}

	/**
	 * Create a hard link to the target file or directory.
	 *
	 * @param string $target
	 * @param string $link
	 * @return void
	 */
	public function link(string $target, string $link): void {
		if (!\Fast\Container::getInstance()->isWindows()) {
			symlink($target, $link);
			exit(1);
		}

		$mode = $this->isDirectory($target) ? 'J' : 'H';

		exec("mklink /{$mode} \"{$link}\" \"{$target}\"");
	}

	/**
	 * Extract the file name from a file path.
	 *
	 * @param string $path
	 * @return string
	 */
	public function name(string $path): string {
		return pathinfo($path, PATHINFO_FILENAME);
	}

	/**
	 * Extract the trailing name component from a file path.
	 *
	 * @param string $path
	 * @return string
	 */
	public function basename(string $path): string {
		return pathinfo($path, PATHINFO_BASENAME);
	}

	/**
	 * Extract the parent directory from a file path.
	 *
	 * @param string $path
	 * @return string
	 */
	public function dirname(string $path): string {
		return pathinfo($path, PATHINFO_DIRNAME);
	}

	/**
	 * Extract the file extension from a file path.
	 *
	 * @param string $path
	 * @return string
	 */
	public function extension(string $path): string {
		return pathinfo($path, PATHINFO_EXTENSION);
	}

	/**
	 * Get the file type of a given file.
	 *
	 * @param string $path
	 * @return string
	 */
	public function type(string $path): string {
		return filetype($path);
	}

	/**
	 * Get the mime-type of a given file.
	 *
	 * @param string $path
	 * @return string|false
	 */
	public function mimeType(string $path): bool|string {
		return finfo_file(finfo_open(FILEINFO_MIME_TYPE), $path);
	}

	/**
	 * Get the file size of a given file.
	 *
	 * @param string $path
	 * @return int
	 */
	public function size(string $path): int {
		return filesize($path);
	}

	/**
	 * Get the file's last modification time.
	 *
	 * @param string $path
	 * @return int
	 */
	public function lastModified(string $path): int {
		return filemtime($path);
	}

	/**
	 * Determine if the given path is a directory.
	 *
	 * @param string $directory
	 * @return bool
	 */
	public function isDirectory(string $directory): bool {
		return is_dir($directory);
	}

	/**
	 * Determine if the given path is readable.
	 *
	 * @param string $path
	 * @return bool
	 */
	public function isReadable(string $path): bool {
		return is_readable($path);
	}

	/**
	 * Determine if the given path is writable.
	 *
	 * @param string $path
	 * @return bool
	 */
	public function isWritable(string $path): bool {
		return is_writable($path);
	}

	/**
	 * Determine if the given path is a file.
	 *
	 * @param string $file
	 * @return bool
	 */
	public function isFile(string $file): bool {
		return is_file($file);
	}

	/**
	 * Find path names matching a given pattern.
	 *
	 * @param string $pattern
	 * @param int $flags
	 * @return array
	 */
	public function glob(string $pattern, int $flags = 0): array {
		return glob($pattern, $flags);
	}

	/**
	 * Get an array of all files in a directory.
	 *
	 * @param string $directory
	 * @return array
	 */
	public function files(string $directory): array {
		$glob = glob($directory . DIRECTORY_SEPARATOR . '*');

		if ($glob === false) {
			return [];
		}
		return array_filter($glob, function ($file) {
			return filetype($file) == 'file';
		});
	}
}
